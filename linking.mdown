## Compiler Drivers
```
/* main.c */
void swap();

int buf[2] = {1, 2};

int main()
{
	swap();
	return 0;
}
```

```
/* swap.c */
extern int buf[];

int *bufp0 = &buf[0];
int *bufp1;

void swap()
{
	int temp;

	bufp1 = &buf[1];
	temp = *bufp0;
	*bufp0 = *bufp1;
	*bufp1 = temp;
}
```
## Relocatable Object Files
.text: The machine code of the compiled program.

.data: *Initialized* global C variables. Local C variables are maintained at run time on the stack, and do not appear in either the .data or .bss sections.

.bss: *Uninitialized* global C variables.

.symtab: A *symbol table* with information about functions and global variables that are defined and referenced in the program.

## Symbols and Symbol Tables
Each relocatable object module, *m*, has a symbol table that contains information about the symbols defined and referenced by *m*. In the context of a linker, there are three different kinds of symbols:
- *Global symbols* that are defined by module *m* and that can be referenced by other modules.
- Global symbols that are referenced by module *m* but defined by some other module. Such symbols are called *externals* and correspond to C functions and variables that are defined in other modules.
- *Local symbols* that are defined and referenced exclusively by module *m*.
An ELF symbol table is contained in the .symtab section. It contains an array of entries.

For example, here are the last three entries in the symbol table for `main.o`, as displayed by the GNU `READELF` tool.
```
Num:    Value  Size Type    Bind   Ot  Ndx  Name
  8:        0     8 OBJECT  GLOBAL  0    3  buf
  9:        0    17 FUNC    GLOBAL  0    1  main
 10:        0     0 NOTYPE  GLOBAL  0  UND  swap
```
In this example, we see an entry for the definition of global symbol `buf`, an 8-byte object located at an offset of zero in the .data section. This is followed by the definition of the global symbol `main`, a 17-byte function located at an offset of zero in the .text section. The last entry comes from the reference for the external symbol `swap`. `READELF` identifies each section by an integer index. `Ndx=1` denotes the .text section, and `Ndx=3` denotes the `.data` section.
## Symbol Resolution
Resolving references to global symbols, however, is trickier. When the compiler encounters a symbol (either a variable or function name) that is not defined in the current module, it assumes that it is defined in some other module, generates a linker symbol table entry, and leaves it for the linker to handle. If the linker is unable to find a definition for the referenced symbol in any of input modules, it prints an error message and terminates. For example, if we try to compile and link the following source file on a Linux machine,
```
void foo(void);

int main() {
	foo();
	return 0;
}
```
then the compiler runs without a hitch, but the linker terminates when it cannot resolve the reference to `foo`:
```
$ gcc -Wall -O2 -o linkerror linkerror.c 
/tmp/cckQhjXS.o: In function `main':
linkerror.c:(.text.startup+0x5): undefined reference to `foo'
collect2: error: ld returned 1 exit status
```
Symbol resolution for global symbols is also tricky because the same symbol might be defined by multiple object files. In this case, the linker must either flag an error or somehow choose one of the definitions and discard the rest.
### How Linkers Resolve Multiply Defined Global Symbols
At compile time, the compiler exports each global symbol to the assembler as either *strong* or *weak*, and the assembler encodes this information implicitly in the symbol table of the relocatable object file. Functions and initialized global variables get strong symbols. For the example program, `buf`, `bufp0`, `main`, and `swap` are strong symbols; `bufp1` is a weak symbol.

Given this notion of strong and weak symbols, Unix linkers use the following rules for dealing with multiply defined symbols:
- Rule 1: Multiple strong symbols are not allowed.

### Linking with Static Libraries
```
gcc -c addvec.c multvec.c
ar rcs libvector.a addvec.o multvec.o

gcc -O2 -c main2.c
gcc -static -o p2 main2.o ./libvector.a
```
The `-static` argument tells the compiler driver that the linker should build a fully linked executable object file that can be loaded into memory and run without any further linking at load time. When the linker runs, it determines that the addvec symbol defined by addvec.o is referenced by main.o, so it copies addvec.o into the executable. Since the program doesn't reference any symbols defined by multvec.o, the linker does not copy this module into the executable. The linker also copies printf.o module from libc.a, along with a number of other modules from the C run-time system.

### How linkers use static libraries to resolve references
During the symbol resolution phase, the linker scans the relocatable object files and archives left to right in the same sequential order that they appear on the compiler driver's command line. During this scan, the linker maintains a set *E* of relocatable object files that will be merged to form the executable, a set *U* of unresolved symbols, and a set *D* of symbols that have been defined in previous input files.
- For each input file f on the command line, the linker determines if f is an object file or an archive. If f is an object file, the linker adds f to *E*, updates *U* and *D* to reflect the symbol definitions and references in f, and proceeds to the nect input file.
- If f is an archive, the linker attempts to match the unresolved symbols in *U* against the symbols defined by the members of the archive. If some archive member, m, defines a symbol that resolves a reference in *U*, then m is addded to *E*, and the linker updates *U* and *D* to reflect the symbol definitions and references in m. This process iterates over the member object files in the archive until a fixed point is reached where *U* and *D* no longer change. At this point, any member object files not contained in *E* are simply discarded and the linker proceeds to the next input file.
- If *U* is nonempty when the linker finishes scanning the input files on the command line, it prints an error and terminates. Otherwise, it merges and relocates the object files in *E* to build the output executable file.

If the library that defines a symbol appears on the command line before the object file that references that symbol, then the reference will not be resolved and linking will fail.
```
gcc -static ./libvector.a main2.c
```
When libvector.a is processed, *U* is empty, so no member object files from libvector.a are added to *E*. Thus, the reference to addvec is never resolved and the linker emits an error message and terminates.

GNU linker option: `--as-needed and --no-as-needed`

This option affects ELF `DT_NEEDED` tags for **dynamic libraries** mentioned on the command line after the `--as-needed` option. Normally the linker will add a `DT_NEEDED` tag for each dynamic library mentioned on the command line, regardless of whether the library is actually needed or not. `--as-needed` causes a `DT_NEEDED` tag to only be emitted for a library that at that point in the link satisfies a non-weak undefined symbol reference from a regular object file or, if the library is not found in the `DT_NEEDED` lists of other libraries, a non-weak undefined symbol reference from another dynamic library. Object files or libraries appearing on the command line after the library in question do not affect whether the library is seen as needed. `--no-as-needed` restores the default behaviour.

## Relocation
Once the linker has completed the symbol resolution step, it has associated each symbol reference in the code with exactly one symbol definition. At this point, the linker knows the exact sizes of the code and data sections in its input object modules. It is now ready to begin the relocation step, where it merges the input modules and assigns run-time addresses to each symbol.

### Relocation entries
When an assembler generates an object module, it does not know where the code and data will ultimately be stored in memory. Nor does it know the locations of any externally defined functions or global variables that are referenced by the module. So whenever the assembler encounters a reference to an object whose ultimate location is unknown, it generates a relocation entry that tells the linker how to modify the reference when it merges the object file into an executable.
```
typedef struct {
	int offset;
	int symbol:24,
	    type:8;
} Elf32_Rel;
```
The `offset` is the section offset of the reference that will need to be modified. The `symbol` identifies the symbol that the modified reference should point to.
### Relocating Symbol References
Assume when the algorithm runs, the linker has already chosen run-time addresses for each section (denoted ADDR(s)) and each symbol (denoted (ADDR)(r.symbol)).

Recall from our running example that the main routine in the .text section of main.o calls the swap routine, which is defined in swap.o. Here is the disassembled listing for the call instruction, as generated by the GNU OBJDUMP tool.
```
6:        e8 fc ff ff ff    call    7 <main+0x7>    swap()
                            7: R_386_PC32 swap      relocation entry
```
We also see a relocation entry for this reference displayed on the following line.
```
r.offset = 0x7
r.symbol = swap
r.type = R_386_PC32
```
These fields tell the linker to modify the 32-bit PC-relative reference starting at offset 0x7 so that it point to the swap routine at run time. Now, suppose that the linker has determined that
```
ADDR(s) = ADDR(.text) = 0x80483b4
ADDR(r.symbol) = ADDR(swap) = 0x80483c8
```
the linker first computes the run-time address of the reference
```
refaddr = ADDR(s) + r.offset
        = 0x80483b4 + 0x7
        = 0x80483bb
```
It then updates the reference from its current value (âˆ’4) to 0x9 so that it will point to the swap routine at run time
```
*refptr = (unsigned) (ADDR(r.symbol) + *refptr - refaddr)
        = (unsigned) (0x80483c8 + (-4) - 0x80483bb)
        = (unsigned) (0x9)
```
## Loading Executable Object Files

To run an executable object file p, we can type its name to the Unix shell's command line:
```
./p
```
Since p does not correspond to a built-in shell command, the shell assumes that p is an executable object file, which it runs for us by invoking some memory-resident operating system code known as the loader. The loader copies the code and data in the executable object file from disk into memory, and then runs the program by jumping to its first instruction, or *entry point*. This process of copying the program into memory and then running it is known as *loading*.
## Dynamic Linking with Shared Libraries
Another issue is that almost every C program uses standard I/O functions such as `printf` and `scanf`. At run time, the code for these functions is duplicated in the text segment of each running process. On a typical system that is running 50â€“100 processes, this can be a significant waste of scarce memory system resources.

*Shared libraries* are modern innovations that address the disadvantages of static libraries. A shared library is an object module that, at run time, can be loaded at an arbitrary memory address and linked with a program in memory. This process is known as dynamic linking and is performed by a program called a dynamic linker.

To build a shared library libvector.so of our example vector arithmetic routines, we would invoke the compiler driver with the following special directive to the linker:
```
gcc -shared -fPIC -o libvector.so addvec.c multvec.c
```
The `-shared` flag directs the linker to create a shared object file.

Once we have created the library, we would then link it into our example program:
```
gcc -o p2 main2.c ./libvector.so
```

This creates an executable object file p2 in a form that can be linked with libvector.so at run time. The basic idea is to do some of the linking statistically when the executable file is created, and then complete the linking process dynamically when the program is loaded.

It is important to realize that none of the code or data sections from libvector.so are actually copied into the executable p2 at this point.

When the loader loads and runs the executable p2, it loads the partially linked executable p2. Next it notices that p2 contains a .interp section, which contains the name of the dynamic linker. Instead of passing control to the application, as it would normally do, the loader loads an runs the dynamic linker.

The dynamic linker then finishes the linking task by performing the following relocations:
- Relocating the text and data of libc.so into some memory segment.
- Relocating the text and data of libvector.so into another memory segment.
- Relocating any references in p2 to symbols defined by libc.so and libvector.so.
```
$ cat /proc/3870/maps
# before addvec() is invoked
...
7f63ea16a000-7f63ea326000 r-xp 00000000 08:02 57675645                   /lib/x86_64-linux-gnu/libc-2.19.so
7f63ea326000-7f63ea525000 ---p 001bc000 08:02 57675645                   /lib/x86_64-linux-gnu/libc-2.19.so
7f63ea525000-7f63ea529000 r--p 001bb000 08:02 57675645                   /lib/x86_64-linux-gnu/libc-2.19.so
7f63ea529000-7f63ea52b000 rw-p 001bf000 08:02 57675645                   /lib/x86_64-linux-gnu/libc-2.19.so
7f63ea52b000-7f63ea530000 rw-p 00000000 00:00 0
7f63ea530000-7f63ea531000 r-xp 00000000 08:02 23069711                   ./libvector.so
7f63ea531000-7f63ea730000 ---p 00001000 08:02 23069711                   ./libvector.so
7f63ea730000-7f63ea731000 r--p 00000000 08:02 23069711                   ./libvector.so
7f63ea731000-7f63ea732000 rw-p 00001000 08:02 23069711                   ./libvector.so
7f63ea732000-7f63ea755000 r-xp 00000000 08:02 57675621                   /lib/x86_64-linux-gnu/ld-2.19.so
...
```

Finally, the dynamic linker passes control to the application. From this point on, the locations os the shared libraries are fixed and do not change during execution.

## Position-Independent Code (PIC)
A better approach is to compile library code so that it can be loaded and executed at any address in virtual address space.

**PIC Data References**

The compiler creates a table called the *global offset table* (GOT) at the beginning of the data segment. The GOT contains an entry for each global data object that is referenced by the object module. The compiler also generates a relocation record for each entry in the GOT. At load time, the dynamic linker relocates each entry in the GOT so that it contains the appropriate absolute address.

**PIC Function Calls**

If an object module calls any functions that are defined in shared libraries, then it has its own GOT and PLT. The GOT is part of the .data section. The PLT is part of the .text section.
Each procedure that is defined in a shared object and called by main2.o gets an entry in the GOT, starting with entry GOT[3]. For the example program, we have shown the GOT entries for printf, which is defined in libc.so, and addvec, which is defined in libvector.so.
```
Address    Entry    Contents   Description
08049674   GOT[0]   0804969c   address of .dynamic section
08049678   GOT[1]   4000a9f8   identifying info for the linker
0804967c   GOT[2]   4000596f   entry point in dynamic linker
08049684   GOT[4]   0804846a   address of pushl in PLT[2] ( addvec )
```
The PLT is an array of 16-byte entries. The first entry, PLT[0], is a special entry that jumps into the dynamic linker. Each called procedure has an entry in the PLT, starting at PLT[1]. In the figure, PLT[1] corresponds to printf and PLT[2] corresponds to addvec.
```
PLT[0]
08048444: ff 35 78 96 04 08 pushl 0x8049678 push &GOT[1]
804844a:  ff 25 7c 96 04 08 jmp *0x804967c  jmp to *GOT[2](linker)
8048450:  00 00                             padding
8048452:  00 00                             padding

PLT[2] <addvec>
8048464: ff 25 84 96 04 08 jmp *0x8049684 jump to *GOT[4]
804846a: 68 08 00 00 00    pushl $0x8     ID for addvec
804846f: e9 d0 ff ff ff    jmp  8048444   jmp to PLT[0]
```
Initially, after the program has been dynamically linked and begins executing, procedures printf and addvec are bound to the first instruction in their respective PLT entries. For example, the call to addvec has the form
```
80485bb:  e8 a4 fe ff ff    call 8048464 <addvec>
```
When addvec is called the first time, control passes to the first instruction in PLT[2], which does an indirect jump through GOT[4]. Initially, each GOT entry contains the address of the pushl entry in the corresponding PLT entry. So the indirect jump in the PLT simply transfers control back to the next instruction in PLT[2]. This instruction pushes an ID for the addvec symbol onto the stack. The last instruction jumps to PLT[0], which pushes another word of identifying information on the stack from GOT[1]. And then jumps into the dynamic linker indirectly through GOT[2]. The dynamic linker uses the two stack entries to determine the location of addvec, overwrites GOT[4] with this address, and passes control to addvec.

The next time addvec is called in the program, control passes to PLT[2] as before. However, this time the indirect jump through GOT[4] transfers control to addvec.