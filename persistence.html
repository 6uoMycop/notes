<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>persistence</title></head><body><article class="markdown-body"><h1 id="persistence"><a name="user-content-persistence" href="#persistence" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Persistence</h1>
<h2 id="hard-disk-drives"><a name="user-content-hard-disk-drives" href="#hard-disk-drives" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Hard Disk Drives</h2>
<p>In this chapter, we dive into more detail about one device in particular: the <strong>hard disk drive</strong>. These drives have been the main form of persistent data storage in computer systems for decades and much of the development of file system technology is predicated on their behavior.</p>
<h3 id="the-interface"><a name="user-content-the-interface" href="#the-interface" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>The Interface</h3>
<p>Let&rsquo;s start by understanding the interface to a modern disk drive. The basic interface for all modern drives is straightforward. The drive consists of a large number of sectors (512-byte blocks), each of which can be read or written. The sectors are numbered from <em><code>0</code></em> to <em><code>n - 1</code></em> on disk with <em><code>n</code></em> sectors. Thus, we can view the disk as an array of sectors.</p>
<p>Multi-sector operations are possible; indeed, many file systems will read or write 4KB at a time (or more). However, when updating the disk, the only guarantee drive manufactures make is that a single 512-byte write is <strong>atomic</strong> (i.e., it will either complete in its entirety or it won&rsquo;t complete at all); thus, if an untimely power loss occurs, only a portion of a larger write may complete.</p>
<h3 id="basic-geometry"><a name="user-content-basic-geometry" href="#basic-geometry" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Basic Geometry</h3>
<p>Let&rsquo;s start to understand some of the components of a modern disk. We start with a <strong>platter</strong>, a circular hard surface on which data is stored persistently by inducing magnetic changes to it. A disk may have one or more platters; each platter has 2 sides, each of which is called a <strong>surface</strong>. These platters are usually made of some hard material (such as aluminum), and then coated with a thin magnetic layer that enables the drive to persistently store bits even when the drive is powered off.</p>
<p>The platters are all bound together around the <strong>spindle</strong>, which is connected to a motor that spins the platters around (while the drive is powered on) at a constant rate.</p>
<p>Data is encoded on each surface in concentric circles of sectors; we call one such concentric circle a <strong>track</strong>. A single surface contains many thousands and thousands of tracks, tightly packed together, with hundreds of tracks fitting into the width of a human hair.</p>
<p>To read and write from the surface, we need a mechanism that allows us to either sense (i.e., read) the magnetic patterns on the disk or to induce a change in (i.e., write) them. This process of reading and writing is accomplished by the <strong>disk head</strong>; there is one such head per surface of the drive. The disk head is attached to a single <strong>disk arm</strong>, which moves across the surface to position the head over the desired track.</p>
<h3 id="a-simple-disk-drive"><a name="user-content-a-simple-disk-drive" href="#a-simple-disk-drive" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>A simple Disk Drive</h3>
<p>Let&rsquo;s understand how disk work by building up a model one track at a time. Assume we have a simple disk with a single track.</p>
<p>This track has just 12 sectors, each of which is 512 bytes in size, and addressed therefore by the numbers 0 through 11. The single platter we have here rotates around the spindle, to which a motor is attached.</p>
<p>In the figure, the disk head, attached to the end of the arm, is positioned over sector 6, and the surface is rotating counter-clockwise.</p>
<p><img alt="A Single Track Plus A Head" src="/home/cheng/materials/disk_single_track.png" /></p>
<p><strong>Single-track Latency: The Rotational Delay</strong></p>
<p>To understand how a request would be processed on our simple, one-track disk, imagine we now receive a request to read block 0.</p>
<p>In our simple disk, the disk doesn&rsquo;t have to do much. In particular, it much just wait for the desired sector to rotate under the disk head. This wait happens often enough in modern drives, and is an important component of I/O service time. that it has a special name: <strong>rotational delay</strong>. A worst case request on this single track would be to sector 5, causing a full rotational delay in order to service such a request.</p>
<p><strong>Multiple Tracks: Seek Time</strong></p>
<p>Let&rsquo;s thus look at ever-so-slightly more realistic disk surface, this one with three tracks.</p>
<p>In the figure, the head is currently positioned over the innermost track (which contains sectors 24 through 35); the next track over contains the next set of sectors (12 through 23), and the outermost track contains the first sectors (0 through 11).</p>
<p>To understand how the drive might access a given sector, we now trace what would happen on a request to a distant sector, e.g., a read to sector 11. To service this read, the drive has first move the disk arm to the correct track (in this case, the outermost one), in a process known as a <strong>seek</strong>.</p>
<p>The seek, it should be noted, has many phases: first an <em>acceleration</em> phase as the disk arm gets moving; then <em>coasting</em> as the arm is moving at full speed, then <em>deceleration</em> as the arm slows down; finally <em>settling</em> as the head is carefully positioned over the correct track. The <strong>settling time</strong> of often significant, e.g., 0.5 to 2 ms, as the drive must be certain to find the right track.</p>
<p>After the seek, the disk arm has positioned the head over the right track. </p>
<p><img alt="Three Tracks Plus A Head (Right: With Seek)" src="/home/cheng/materials/disk_multiple_track.png" /></p>
<p>As we can see, during the seek, the arm has been moved to the desired track, and the platter of course has rotated, in this case about 3 sectors. Thus, sector 9 is just about to pass under the disk head, and we must only endure a short rotational delay to complete the transfer.</p>
<p>When sector 11 passes under the disk head, the final phase of I/O will take place, known as the <strong>transfer</strong>, where data is either read from or written to the surface. ANd thus, we have a complete picture of I/O time: first a seek, then waiting for the rotational delay, and finally the transfer.</p>
<p><strong>Some other details</strong></p>
<p>Finally an important part of nay modern disk drive is its <strong>cache</strong>. This cache is just some small amount of memory which the drive can use to hold data read from or written to the disk. For example, when reading a sector from the disk, the drive might decide to read in all of the sectors on that track and cache them in its memory; doing so allows the drive to quickly respond to any subsequent requests to the same track.</p>
<p>On writes, the drive has a choice: should it acknowledge the write has completed when it has put the data it in its memory, or after the write has actually been written to disk? The former is called <strong>write back</strong> caching, and the latter <strong>write through</strong>. Write back caching sometimes makes the drive appear &ldquo;faster&rdquo;, but can be dangerous. </p>
<h2 id="redundant-arrays-of-inexpensive-disks-raids"><a name="user-content-redundant-arrays-of-inexpensive-disks-raids" href="#redundant-arrays-of-inexpensive-disks-raids" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Redundant Arrays of Inexpensive Disks (RAIDs)</h2>
<p>In this chapter, we introduce the <strong>Redundant Array of Inexpensive Disks</strong> better known as <strong>RAID</strong>, a technique to use multiple disks in concert to build a faster, bigger, and more reliable disk system.</p>
<p>Externally, a RAID looks like a disk: a group of blocks one can read or write. Internally, the RAID is a complex beast, consisting of multiple disks, memory (both volatile and non-), and one or more processors to manage the system. A hardware RAID Is very much like a computer system, specialized for the task of managing a group of disks.</p>
<p>RAID offers a number of advantages over a single disk. One advantage is <em>performance</em>. Using multiple disks in parallel can greatly speed up I/O times. Another benefit is <em>capacity</em>. Large data sets demand large disks. Finally, RAIDs can improve <em>realizability</em>; spreading data across multiple disks (without RAID techniques) makes the data vulnerable to the loss of a single disk; with some of <strong>redundancy</strong>, RAIDs can tolerate the loss of a disk and keep operating as if nothing were wrong.</p>
<p>Amazingly, RAIDs provide these advantages <strong>transparently</strong> to systems that use them, i.e., a RAID just looks like a big disk to the host system. The beauty of transparency, of course, is that it enables one to simply replace a disk with a RAID and not change a single line of software; the operating system and client applications continue to operate without modification. In this manner, transparency greatly improves the <strong>deployability</strong> of RAID, enabling users and administrators to put a RAID to use without worries of software compatibility.</p>
<h3 id="how-to-evaluate-a-raid"><a name="user-content-how-to-evaluate-a-raid" href="#how-to-evaluate-a-raid" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>How To Evaluate A RAID</h3>
<p>Specifically, we will evaluate each RAID design along three axes. The first axes is <strong>capacity</strong>; given a set of <em>N</em> disks each with <em>B</em> blocks, how much useful capacity is available to clients of the RAID? Without redundancy, the answer is <em>N * B</em>; in contrast, if we have a system that keeps two copies of each block (called <strong>mirroring</strong>), we obtain a useful capacity of <em>(N * B) / 2</em>. Different schemes (e.g., party-based ones) tend to fall in between.</p>
<p>The second axis of evaluation is <strong>reliability</strong>. How many disk faults can the given design tolerate?</p>
<p>Finally, the third axis is <strong>performance</strong>. Performance is somewhat challenging to evaluate, because it depends heavily on the workload presented to the disk array. Thus before evaluating performance, we will first present a set of typical workloads that one should consider.</p>
<p>We now consider three important RAID designs: RAID Level 0 (striping), RAID 1 (mirroring), and RAID Level 4/5 (parity-based redundancy).</p>
<h3 id="raid-level-0-striping"><a name="user-content-raid-level-0-striping" href="#raid-level-0-striping" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>RAID Level 0: Striping</h3>
<p>The first RAID level is actually not a RAID level at all, in that there is no redundancy. However, RAID level 0, or <strong>stripping</strong> as it is better known, serves as an excellent upper-bound on performance and capacity and thus is worth understanding.</p>
<p>The simplest form of stripping will <strong>stripe</strong> blocks across the disks of the systems as follows (assume here a 4-disk array):</p>
<table>
<thead>
<tr>
<th>Disk 0</th>
<th>Disk 1</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content from cell 1</td>
<td>Content from cell 2</td>
</tr>
<tr>
<td>Content in the first column</td>
<td>Content in the second column</td>
</tr>
</tbody>
</table>
<h2 id="interlude-files-and-directories"><a name="user-content-interlude-files-and-directories" href="#interlude-files-and-directories" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Interlude: Files and Directories</h2>
<h3 id="files-and-directories"><a name="user-content-files-and-directories" href="#files-and-directories" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Files and Directories</h3>
<p>Two key abstractions have developed over time in the virtualization of storage. The first file is the <strong>file</strong>. A file is simply a linear of bytes, each of which you can read or write. Each file has some kind of <strong>low-level name</strong>, usually a number of some kind. For historical reasons, the low-level name of a file is often referred to as its <strong>inode number</strong>. for now, just assume that each file has an inode number associated with it.</p>
<p>In most systems, the OS does not know much about the structure of the file (e.g., whether it is a picture, or a text file, or a text file, or C code); rather, the responsibility of the file system is simply to store such data persistently on disk and make sure that when you request the data again, you get what you put there in there in the first place.</p>
<p>The second abstraction is that of a <strong>directory</strong>. A directory, like a file, also has a <strong>low-level name</strong> (i.e., an inode number), but its contents are quite specific: it contains a list of (user-readable name, low-level name) pairs. For example, let&rsquo;s say there is a file with the low-level name &ldquo;10&rdquo;, and it is referenced to by the user-readable name of &ldquo;foo&rdquo;. The directory that &ldquo;foo&rdquo; resides in thus would have an entry (&ldquo;foo&rdquo;, &ldquo;10&rdquo;) that maps the user-readable name to the low-level name. Each entry in a directory refers to either files or directories. By placing directories within other directories, users are able to build an arbitrary <strong>directory tree</strong>, under which all files and directories are stored.</p>
<h3 id="removing-files"><a name="user-content-removing-files" href="#removing-files" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Removing Files</h3>
<p>If you&rsquo;ve used UNIX, you probably think you know: just run the program <code>rm</code>. But what system call does <code>rm</code> use to remove a file?</p>
<p>Let&rsquo;s use our old friend <code>strace</code> again to find out. Here we remove that pesky file &ldquo;foo&rdquo;:<br />
<pre><code>prompt&gt; strace rm foo
...
unlink(&quot;foo&quot;)                          = 0
...
</code></pre><br />
We&rsquo;ve removed a bunch of unrelated cruft from the traced output, leaving just a single call to the mysteriously-named system call <code>unlink()</code>. As you can see, <code>unlink()</code> just takes the name of the file to be removed, and returns zero upon success. But this leads us to a great puzzle: why is this system call named &ldquo;unlink&rdquo;? Why not just &ldquo;remove&rdquo; or &ldquo;delete&rdquo;.</p>
<h3 id="hard-links"><a name="user-content-hard-links" href="#hard-links" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Hard Links</h3>
<p>We now come back to the mystery of why removing a file is performed via <code>unlink()</code>, by understanding a new way to make an entry in the file system tree, through a system call known as <code>link()</code>. The <code>link()</code> system call takes two arguments, an old pathname and a new one; when you &ldquo;link&rdquo; a new file name to an old one, you essentially create another way to refer to the same file. The command-line program <code>ln</code> is used to do this, as we see in this example:<br />
<pre><code>prompt&gt; echo hello &gt; file
prompt&gt; cat file
hello
prompt&gt; ln file file2
prompt&gt; cat file2
hello
</code></pre><br />
Here we created a file with the word &ldquo;hello&rdquo; in it, and called the file <code>file</code>. We then create a hard link to that file using the <code>ln</code> program. After this, we can examine the file by either opening <code>file</code> or <code>file2</code>.</p>
<p>The way link works is that it simply creates another name in the directory you are creating the link to, and refers it to the <em>same</em> inode number (i.e., low-level name) of the original file. The file is not copied in any way; rather, you now just have two human names (<code>file</code> and <code>file2</code>) that both refer to the same file. We can even see this in the directory itself, by printing out the inode number of each file:<br />
<pre><code>prompt&gt; ls -i file file2
67158084 file
67158084 file2
prompt&gt;
</code></pre><br />
By passing the <code>-i</code> flag to <code>ls</code>, it prints out the inode number of each file (as well as the file name). And thus you can see what link really has done: just make a new reference to the same exact inode number (67158084 in this example).</p>
<p>By now you might be starting to see why <code>unlink()</code> is called <code>unlink()</code>. When you create a file, you are really doing <em>two</em> things. First, you are making a structure (the inode) that will track virtually all relevant information about the file, including its size, where its blocks are on disk, and so forth. Second, you are <em>linking</em> a human-readable name to that file, and putting that link into a directory.</p>
<p>After creating a hard link to a file, to the file system, there is no difference between the original file name (<code>file</code>) and the newly created file name (<code>file2</code>); indeed, they are both just links to the underlying metadata about the file, which is found in inode number 67158084.</p>
<p>Thus, to remove a file from the file system, we call <code>unlink()</code>.</p>
<p>In the example above, we could for example remove the file named <code>file</code>, and still access the file without difficulty:<br />
<pre><code>prompt&gt; rm file
removed 'file'
prompt&gt; cat file2
hello
</code></pre><br />
The reason this works is because when the file system unlinks file, it checks a <strong>reference count</strong> within the inode number. This reference count allows the file system to track how many different file names have been linked to this particular inode. When <code>unlink()</code> is called, it removes the &ldquo;link&rdquo; between the human-readable name (the file that is being deleted) to the given inode number, and decrements the reference count; only when the reference count reaches zero does the file system also free the inode and related data blocks, and thus truly &ldquo;delete&rdquo; the file.</p>
<h3 id="symbolic-links"><a name="user-content-symbolic-links" href="#symbolic-links" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Symbolic Links</h3>
<p>There is one other type of link that is really useful, and it is called a <strong>symbolic link</strong> or sometimes a <strong>soft link</strong>.</p>
<p>To create such a link, you can use the same program <code>ln</code>, but with the <code>-s</code> flag. Here is an example:<br />
<pre><code>prompt&gt; echo hello &gt; file
prompt&gt; ln -s file file2
prompt&gt; cat file2
hello
</code></pre><br />
As you can see, creating a soft link looks much the same, and the original file can now be accessed through the file name <code>file</code> as well as the symbolic link name <code>file2</code>.</p>
<p>However, beyond this surface similarity, symbolic links are actually quite different from hard links. The first difference is that a symbolic link is actually a file itself, of a different type. We&rsquo;ve already talked about regular files and directories; symbolic links are a third type the file system knows about.</p>
<p>Running <code>ls</code> also reveals this fact. If you look closely at the first character of the long-form of the output from <code>ls</code>, you can see that the first character in the left-most column is a - for regular files, a <code>d</code> for directories, and an <code>l</code> for soft links. You can also see the size of the symbolic link (4 bytes in this case), as well as what the link points to (the file named <code>file</code>).<br />
<pre><code>prompt&gt; ls -al
drwxr-x--- 2  remzi remzi   29 May 3 19:10 ./
drwxr-x--- 27 remzi remzi 4096 May 3 15:14 ../
-rw-r----- 1  remzi remzi    6 May 3 19:10 file
lrwxrwxrwx 1  remzi remzi    4 May 3 19:10 file2 -&gt; file
</code></pre><br />
The reason that <code>file2</code> is 4 bytes is because the way a symbolic link is formed is by holding the pathname of the linked-to file as the data of the link file. Because we&rsquo;ve linked to a file named <code>file</code>, our link file <code>file2</code> is small (4 bytes). If we link to a longer pathname, our link file would be bigger:<br />
<pre><code>prompt&gt; echo hello &gt; alongerfilename
prompt&gt; ln -s alongerfilename file3
prompt&gt; ls -al alongerfilename file3
-rw-r----- 1 remzi remzi  6 May 3 19:17 alongerfilename
lrwxrwxrwx 1 remzi remzi 15 May 3 19:17 file3 -&gt; alongerfilename
</code></pre><br />
Finally, because of the way symbolic links are created, they leave the possibility for what is known as a <strong>dangling reference</strong>:<br />
<pre><code>prompt&gt; echo hello &gt; file
prompt&gt; ln -s file file2
prompt&gt; cat file2
hello
prompt&gt; rm file
prompt&gt; cat file2
cat: file2: No such file or directory
</code></pre><br />
As you can see in this example, quite unlike hard links, removing the original file named <code>file</code> causes the link to point to a pathname that no longer exists.</p>
<h3 id="making-and-mounting-a-file-system"><a name="user-content-making-and-mounting-a-file-system" href="#making-and-mounting-a-file-system" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Making and Mounting a File System</h3>
<p>To make a file system, most file systems provide a tool, usually referred to as <code>mkfs</code>, that performs exactly this task. The idea is as follows: give the tool, as input, a device (such a disk partition, e.g., <code>/dev/sda1</code>) a file system type (e.g., ext3), and it simply writes an empty file system, starting with a root directory, onto that disk partition. And mkfs said, let there be a file system.</p>
<p>However, once such a file system is created, it needs to be made accessible within the uniform file-system tree. This task is achieved via the <code>mount</code> program. What mount does, quite simply is take an existing directory as a target <strong>mount point</strong> and essentially paste a new file system onto the directory at that point.</p>
<p>Imagine we have an unmounted ext3 file system, stored in device partition <code>/dev/sda1</code>, that has the following contents: a root directory which contains two sub-directories, <code>a</code> and <code>b</code>, each of which in turn holds a single file named <code>foo</code>. Let&rsquo;s say we wish to mount this file system at the mount point <code>/home/users</code>. We would type something like this:<br />
<pre><code>prompt&gt; mount -t ext3 /dev/sda1 /home/users
</code></pre><br />
If successful, the mount would thus make this new file system available.</p>
<h2 id="file-system-implementation"><a name="user-content-file-system-implementation" href="#file-system-implementation" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>File System Implementation</h2>
<h3 id="overall-organization"><a name="user-content-overall-organization" href="#overall-organization" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Overall Organization</h3>
<p>We now develop the overall on-disk organization of the data structure of the vsfs file system. The first thing we&rsquo;ll need to do is divide the disk into blocks; simple file systems use just one block size, and that&rsquo;s exactly what we&rsquo;ll do here. Let&rsquo;s choose a commonly-used size of 4KB.</p>
<p>Thus, our view of the disk partition where we&rsquo;re building our file system is simple: a series of blocks, each of size 4KB. The blocks are addressed from <em><code>0</code></em> to <em><code>N - 1</code></em>, in a partition of size <em><code>N</code></em> 4-KB blocks. Assume we have a really small disk, with just 64 blocks.</p>
<p>Let&rsquo;s now think about what we need to store in these blocks to build a file system. Of course, the first thing that comes to mind is user data. In fact, most of the space in any file system is (and should be) user data. Let&rsquo;s call the region of the disk we use for user data the <strong>data region</strong>, again for simplicity, reserve a fixed portion of the disk for these blocks, say the last 56 of 64 blocks on the disk.</p>
<p>the file system has to track information about each file. This information is a key piece of <strong>metadata</strong>, and tracks things like which data blocks (in the data region) comprise a file, the size of the file, its owner and access rights, access and modify times, and other similar kinds of information. To store this information, file systems usually have a structure called an <strong>inode</strong>.</p>
<p>To accommodate inodes, we&rsquo;ll need to reserve some space on the disk for them as well. Let&rsquo;s call this portion of the disk the <strong>inode table</strong>, which simply holds an array of on-disk inodes.</p>
<p>We should note here that inodes are typically not that big, for example 128 or 256 bytes. Assuming 256 bytes per inode, a 4-KB block can hold 16 inodes, and our file system above contains 80 total inodes. In our simple file system, built on a tiny 64-block partition, this number represents the maximum number of files we can have in our file system.</p>
<p>Our file system thus far has data blocks (D), and inodes (I), but a few things are still missing. One primary component that is still needed, as you might have guessed, is some way to track whether inodes or data blocks are free or allocated.</p>
<p>We instead choose a simple and popular structure known as a <strong>bitmap</strong>, one for the data region (the <strong>data bitmap</strong>), and one for the inode table (the <strong>inode bitmap</strong>). A bitmap is a simple structure: each bit is used to indicate whether the corresponding object/block is free (0) or in-use (1).</p>
<p><img alt="File System Data Structure" src="/home/cheng/materials/file_system_data_structure.png" /></p>
<p>The careful reader may have noticed there is one block left in the design of the on-disk structure of our very simple file system. We reserve this for the <strong>superblock</strong>, denoted by an S in the diagram below. The superblock contains information about this particular file system, including, for example, how many inodes and data blocks are in the file system (80 and 56, respectively in this instance), where the inode table begins (block 3), and so forth. It will likely also include a magic number of some kind to identify the file system type (in this case, vsfs).</p>
<h3 id="file-organization-the-inode"><a name="user-content-file-organization-the-inode" href="#file-organization-the-inode" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>File Organization: The Inode</h3>
<p>Each inode is implicitly referred to by a number (called the <strong>inumber</strong>), which we&rsquo;ve earlier called the <strong>low-level</strong> name of the file. In vsfs (and other simple file systems), given an i-number, you should directly be able to calculate where on the disk the corresponding inode is located.</p>
<p>To read inode number 32, the file system would first calculate the offset into the inode region (<code>32 * sizeof(inode)</code>), add it to the start address of the inode table on disk (<code>inodeStartAddr = 12KB</code>), and thus arrive upon the correct byte address of the desired block of inodes: 20KB. Recall that disks are not byte addressable, but rather consist of a large number of addressable sectors, usually 512 bytes. Thus, to fetch the block of inodes that contains inode 32, the file system would issue a read to sector <code>20 * 1024 / 512</code> to fetch the desired inode block.</p>
<h3 id="access-paths-reading-and-writing"><a name="user-content-access-paths-reading-and-writing" href="#access-paths-reading-and-writing" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Access Paths: Reading and Writing</h3>
<p><strong>Reading A File From Disk</strong></p>
<p>In this simple example, let us first assume that you want to simply open a file (e.g., <code>/foo/bar</code>).</p>
<p>When you issue an <code>open("/foo/bar", O_RDONLY)</code> call, the file system first needs to find the inode for the file <code>bar</code>, to obtain some basic information about the file (permissions information, file size, etc.). To do so, the file system must be able to find the inode, but all it has right now is the full pathname. The file system must <strong>traverse</strong> the pathname and thus locate the desired inode.</p>
<p>All traversals begin at the root of the file system, in the <strong>root directory</strong> which is simply called /. Thus, the first thing the FS will read from disk is the inode of the root directory. But where is this inode? To find an inode, we must know its i-number. Usually, we find the i-number of a file or directory in its parent directory; the root has no parent (by definition). Thus, the root inode number must be &ldquo;well known&rdquo;; the FS must know what it is when the file system is mounted. In most UNIX file systems, the root inode number is 2. Thus, to begin the process, the FS reads in the block that contains inode number 2 (the first inode block).</p>
<p>Once the inode is read in, the FS can look inside of it to find pointers to data blocks, which contain the contents of the root directory. The FS will thus use these on-disk pointers to read through the directory, in this case looking for an entry for <code>foo</code>. By reading in one or more directory data blocks, it will find the entry for <code>foo</code>; once found, the FS will also have found the inode number of <code>foo</code> (say it is 44) which it will need next.</p>
<p>The next step is to recursively traverse the pathname until the desired inode is found. In this example, the FS reads the block containing the inode of <code>foo</code> and then its directory data, finally finding the inode number of <code>bar</code>. The final step of <code>open()</code> is to read <code>bar</code>&lsquo;s inode into memory; the FS then does a final permissions check, allocates a file descriptor for this process in the per-process open-file table, and returns it to the user.</p>
<h2 id="crash-consistency-fsck-and-journaling"><a name="user-content-crash-consistency-fsck-and-journaling" href="#crash-consistency-fsck-and-journaling" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Crash Consistency: FSCK and Journaling</h2>
<h3 id="a-detailed-example"><a name="user-content-a-detailed-example" href="#a-detailed-example" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>A detailed example</h3>
<p>We need to use a <strong>workload</strong> that updates on-disk structures in some way. Assume here that the workload is simple: the append of a single data block to an existing file. The append is accomplished by opening the file, calling <code>lseek()</code> to move the file offset to the end of the file, and then issue a 4KB write to the file before closing it.</p>
<p>This tiny example includes an <strong>inode bitmap</strong> (with just 8bits, one per inode), a <strong>data bitmap</strong> (also 8 bits, one per data block), inodes (8 total, numbered 0 to 7, and spread across four blocks), and data blocks (8 total, numbered 0 to 7). Here is a diagram of this file system:<br />
<img alt="" src="/home/cheng/materials/crash_consistency_fig1.png" /></p>
<p>If you look at the structures in the picture, you can see that a single inode is allocated (inode number 2), which is marked in the inode bitamp, and a single allocated data block (data block 4), also marked in the data bitmap. The inode is denoted I[v1], as it is the first version of this inode; it will soon be updated.</p>
<p>Let&rsquo;s peek insode this simplified inode too. Inside of I[v1], we see:<br />
<pre><code>owner       : remzi
permissions : read-write
size:       : 1
pointer     : 4
pointer     : null
pointer     : null
pointer     : null
</code></pre><br />
In this simplified example, the <code>size</code> of the file is ` (it has one block allocated), the first pointer points to block 4 (the first block of the file, Da), and all three other pointers are set to null (indicating they are not used).</p>
<p>When we append to the file, we are adding a new data block to it, and must update three on-disk structures: the inode (which must point to the new block as well as have a bigger size due to the append), the new data block Db, and a new version of the data bitmap (call it B[v2]) to indicate that new data block has been allocated.</p>
<p>Thus, in memory of the system, we have three blocks which we must write to disk. The updated inode (inode version 2, or I[v2] for short) now looks like this:<br />
<pre><code>owner       : remzi
permissions : read-write
size:       : 2
pointer     : 4
pointer     : 5
pointer     : null
pointer     : null
</code></pre><br />
The updated data bitmap (B[v2]) now looks like this: 00001100. Finally, there is the data block (Db), which is just filled with whatever it is users put into files.</p>
<p>What we would like is for the final on-disk image of the file system to look like this:<br />
<img alt="" src="/home/cheng/materials/crash_consistency_fig2.png" /></p>
<p>To achieve this transition, the file system must perform three separate writes to disk, one each for the inode(I[v2]), bitmap (B[v2]), and the data block. Note that these writes usually don&rsquo;t happen immediately when the user issues a <code>write()</code> system call; rather, the dirty inode, bitmap, and new data will sit in main memory (int the <strong>page cache</strong> or <strong>buffer cache</strong>) for some time first; then, when the file system finally decides to write them to disk (after say 5 seconds or 30 seconds), the file system will issue the requisite write requests to the disk. Unfortunately, a crash may occur and thus interfere with these updates to the disk. In particular, if a crash happens after one or two of these writes have taken place, but not all three, the file system could be left in a funny state.</p>
<p>To understand the problem better, let&rsquo;s look at some example crash scenarios. Image only a single write succeeds; there are thus three possible outcomes, which we list here:<br />
- <strong>Just the data block (Db) is written to disk.</strong> In this case, the data is on disk, but there is no inode that points to it and no bitmap that even says the block is allocated.<br />
- <strong>Just the updated inode (I[v2]) is written to disk.</strong> In this case, the inode points to to the disk address (5) where Db was about to be written, but Db has not yet been written there. Thus, if we trust that pointer, we will read <strong>garbage</strong> data from the disk (the old contents of disk address 5).</p>
<p>Furthermore, we have a new problem, which we call a <strong>file-system inconsistency</strong>. The on-disk bitmap is telling us that data on block 5 has not been allocated, but the inode is saying it has. This disagreement in the file system data structures is an inconsistency in the data structures of the file system; to use the file system, we must somehow resolve this problem.<br />
- <strong>Just the updated bitmap (B[v2]) is written to disk.</strong> In this case, the bitmap that block 5 is allocated, but there is no inode that points to it. Thus the file system is inconsistent again; if left unresolved, this write would result in a <strong>space leak</strong>, as block 5 would never be used by the file system.</p>
<p>There are three more crash scenarios in this attemp to write three blocks to disk. In these case, two writes succeed and the last one fails:<br />
- <strong>The inode (I[v2]) and bitmap (B[v2]) are written to disk, but no data (Db).</strong> In this case, the file system metadata is completely consistent: the inode has pointer to block 5, the bitmap indicates that 5 is in use, and thus everything looks OK from the perspective of the file system&rsquo;s metadata. But there is one problem: 5 has garbage in it again.<br />
- <strong>The inode (I[v2]) and the data block (Db) are written, but not the bitmap(B[v2]).</strong> In this case, we have the inode pointing to the correct data on disk, but again have an inconsistency problem between the inode and the old version of the bitmap (B1). Thus, we once again need to solve the problem before using the file system.<br />
- <strong>The bitmap (B[v2]) and data block (Db) are written, but not the inode (I[v2]).</strong> In this case, we again have an inconsistency problem between the inode and the data bitmap. However, even though the block was written and the bitmap indicates its usage, we have no idea which file it belongs to, as no inode points to the file.</p>
<h3 id="journaling-or-write-ahead-logging"><a name="user-content-journaling-or-write-ahead-logging" href="#journaling-or-write-ahead-logging" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Journaling (or Write-Ahead Logging)</h3>
<p>The basic idea is as follows. When updating the disk, before overwriting the structures in place, first write down a little note (somewhere else on the disk, in a well-known location) describing what you are about to do. Writing this note is the &ldquo;write ahead&rdquo; part, and we write it to a structure that we organize as a &ldquo;log&rdquo;; hence, write-ahead logging.</p>
<p>By writing the notes to disk, you are guaranteeing that if a crash takes place during the update (overwrite) of the structures you are updating, you can go back and look at the note you made and try again; thus, you will know exactly what to fix (and how to fix it) after a crash. By design, journaling adds a bit of work during updates to greatly reduce the amount of work required during recovery.</p>
<p>We&rsquo;ll now describe how <strong>Linux ext3</strong>, a popular journaling file system, incorporates journaling into the file system. Most of the on-disk structures are identical to <strong>Linux ext2</strong>, e.g., the disk is divided into block groups, and each block group has an inode and data bitmap as well as inodes and data blocks. The new key structure is the journaling itself. which occupies some small amount of space within the partition or on another device. Thus, an ext2 file system (without journaling) looks like this:<br />
<img alt="" src="/home/cheng/materials/crash_consistency_fig3.png" /></p>
<p>Assuming the journal is placed within the same file system image (though sometimes it is placed on a separate device, or as a file within the file system), an ext3 file system with a journal looks like this:<br />
<img alt="" src="/home/cheng/materials/crash_consistency_fig4.png" /></p>
<p>The real difference is just the presence of the journal, and of course, how it is used.</p>
<p>Data journaling is available as mode with the Linux ext3 file system, from which much of this discussion is based.</p>
<p>Say we have canonical update again, where we wish to write the inode (I[v2]), bitmap (B[v2]) and data block (Db) to disk again. Before writing them to their final disk locations, we are now first going to write them to the log (a.k.a journal). This is what this will look like in the log:<br />
<img alt="" src="/home/cheng/materials/crash_consistency_fig5.png" /></p>
<p>You can see we have written five blocks here. The transactional begin (TxB) tells us about this update, including information about pending update to the file system (e.g., the final address of the block (I[v2]), B[v2], and Db) as well as some kind of <strong>transactional identifier (TID)</strong>. The middle three blocks just contain the exact contents of the blocks themselves, this is known as <strong>physical logging</strong> as we are putting the exact physical contents of the update in the journal (an alternative idea, <strong>logical logging</strong>, puts a more compact logical representation of the updates in the journal, e.g., &ldquo;this update wishes to append data block Db to file X&rdquo;, which is a little more complex but can save space in the log and perhaps improve performance). The final block (TxE) is a marker of the end of this transaction, and will also contain the TID.</p>
<p>Once this transaction is safely on disk, we are ready to overwrite the old structure in the file system; this process is called <strong>checkpointing</strong>. Thus, to <strong>checkpoint</strong> the file system (i.e., bring it up to date with the pending update in the journal), we issue the writes I[v2], B[v2], and Db to their disk locations as seen above; if these writes complete successfully, we have successfully checkpointed the file system and are basically done. Thus, our initial sequence of operations:<br />
- <strong>Journal writing:</strong> Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.<br />
- <strong>Checkpoint:</strong> Write the pending metadata and updates to their final locations in the file system.<br />
In our example, we would write TxB, I[v2], B[v2], Db, and TxE to the journal first. When those writes complete, we would complete the updates by checkpointing I[v2], B[v2], and Db, to their final locations on disk.</p>
<p>Things get a little tricker when a crash occurs during the writes to the journal. Here, we are trying to write the set of blocks in the transaction (e.g., TxB, I[v2], B[v2], Db, TxE) to disk. Ideally, we&rsquo;d like to issue all five block writes at once. However, this is unsafe, for the following reason: given such a big write, the disk internally may perform scheduling and complete small pieces of the big write in any order. Thus, the disk internally may (1) write TxB, I[v2], B[v2], and TxE and only later (2) write Db. Unfortunately, if the disk loses power between (1) and (2), this is what ends up on disk:<br />
<img alt="" src="/home/cheng/materials/crash_consistency_fig6.png" /></p>
<p>Why is this a problem? Well, the transaction looks like a valid transaction (it has a begin and and end with matching sequence numbers). Furthermore, the file system can&rsquo;t look at that fourth block and know it is wrong; after all, it is arbitrary data. Thus, if the file system now reboots and runs recovery, it will replay this transaction, and ignorantly copy the contents of the garbage block &ldquo;??&rdquo; to the location where Db is supposed to live. This is bad for arbitrary user data in a life; it is much worse if it happens to a critical piece of the file system, such as the superblock, which could render the file system unmountable.</p>
<p>To avoid this problem, the file system issues the transaction write in two steps. First, it writes all blocks except the TxE block to the journal, issuing these writes all at once. When these writes are complete, the journal will look something like this:<br />
<img alt="" src="/home/cheng/materials/crash_consistency_fig7.png" /></p>
<p>When those writes complete, the file system issues the write of the TxE block, thus leaving the journal in this final, safe state:<br />
<img alt="" src="/home/cheng/materials/crash_consistency_fig8.png" /></p>
<p>An important aspect of this process is the atomicity guarantee provided by the disk. It turns out that the disk guarantees that any 512-byte write will either happen or not (and never be half-written); thus, to make sure the write of TxE is atomic, one should make it a single 512-byte block. Thus, our current protocol to update the file system, with each of its three phases labeled:<br />
- <strong>Journal write:</strong> Write the contents of the transaction (including TxB, metadata, and data) to the log; wait for these writes to complete.<br />
- <strong>Journal commit</strong>: Write the transaction commit block (containing TxE) to the log; wait for write to complete; transaction is said to be <strong>committed</strong>.<br />
- Checkpoint: Write the contents of the update (metadata and data) to their final on-disk locations.</p>
<p>Let’s now understand how a file system can use the contents of the journal to <strong>recover</strong> from a crash. A crash may happen at any time during this sequence of updates. If the crash happens before the transaction is written safely to the log, then our job is easy: the pending update is simply skipped. If the crash happens after the transaction has committed to the log, but before the checkpoint is complete, the file system can <strong>recover</strong> the update as follows. When the system boots, the file system recovery process will scan the log and look for transactions that have committed to the disk; these transactions are thus <strong>replayed</strong> (in order), with the file system again attempting to write out the blocks in the transaction to their final on-disk locations. This form of logging is one of the simplest forms there is, and is called <strong>redo logging</strong>.</p></article></body></html>