# GNU Make
## An Introduction to Makefiles
You need a file called a *makefile* to tell `make` what to do. Most often, the makefile tells `make` how to compile and link a program.

we will discuss a simple makefile that describes how to compile and link a text editor which consists of eight C source files and three header files. The makefile can also tell `make` how to run miscellaneous commands and explicitly asked (for example, to remove certain files as a clean-up operation).

### What a Rule Looks Like
A simple makefile consists of "rules" with the following shape:
```
target … : prerequisites …
	recipe
	…
	…
```
A *target* is usually the name of a file that is generated by a program; examples of targets are executables or object files. A target can also be the name of an action to carry out, such as `'clean'`.

A prerequisite is a file that is used as input to create the target. A target often depends on several files.

A recipe is an action that `make` carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line!

Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change. However, the rule that specifies a recipe for the target need not have prerequisites. For example, the rule containing the delete command associated with the target `'clean'` does not have prerequisites.

### A Simple Makefile
Here is a straightforward makefile that describes the way an executable file called `edit` depends on eight object files which, in turn, depend on eight C source and three header files.
```Makefile
edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o
	cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o

main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o
```
To use this makefile to create the executable file called `edit`, type:
```
make
```
To use this makefile to delete the executable file and all the object files from the directory, type:
```
make clean
```
In the example makefile, the targets include the executable file `'edit'`, and the object files `'main.o'` and `'kbd.o'`. The prerequisites are files such as `'main.c'` and `'defs.h'`. In fact, each `'.o'` file is both a target and a prerequisite.

When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change. In addition, any prerequisites that are themselves automatically generated should be updated first. In this example, `edit` depends on each of the eight object files; the object file `main.o` depends on the source file `main.c` and on the header file `defs.h`.

The target `'clean'` is not a file, but merely the name of an action. Since you normally do not want to carry out the actions in this rule, `'clean'` is not a prerequisite of any other rule. Consequently, `make` never does anything with it unless you tell it specifically. Note that this rule not only is not a prerequisite, it also does not have any prerequisites, so the only purpose of the rule is to run the specified recipe. Targets that do not refer to files but are just actions are called *phony targets*.

### How `make` Processes a Makefile
By default, `make` starts with the first target. This is called the *default goal*.

In the simple example of the previous section, the default goal is to update the executable program `edit`; therefore, we put that rule first.

Thus, when you give the command:
```
make
```
`make` reads the makefile in the current directory and begins by processing the first rule. In the example, this rule is for relinking `edit`; but before make can fully process this rule, it must process the rules for the files that `edit` depends on, which in this case are the object files. Each of these files is processed according to its own rule. These rules say to update each `'.o'` file by compiling its source file. The recompilation must be done if the source file, or any of the header files **named as prerequisites**, is more recent than the object file, or if the object file does not exist.

The other rules are processed because their targets appear as prerequisites of the goal. If some other rule is not depended on by the goal (or anything it depends on, etc.), that rule is not processed, unless you tell `make` to do so (with a command such as `make clean`).

After recompiling whichever object files need it, `make` decides whether to relink `edit`. This must be done if the file `edit` does not exist, or if any of the object files are newer than it. If an object file was just recompiled, it is now newer than `edit`, so `edit` is relinked.

Thus, if we change the file `insert.c` and run `make`, `make` will compile that file to update `insert.o`, and then link `edit`. If we change the file `command.h` and run `make`, `make` will recompile the object files `kbd.o`, `command.o` and `files.o` and then link the file `edit`.

## Writing Makefiles
### What Makefiles Contain
#### Splitting Long Lines
However, it is difficult to read lines which are too long to display without wrapping or scrolling. So, you can format your makefiles for readability by adding newlines into the middle of a statement: you do this by escaping the internal newlines with a backslash (\\) character.

### Including Other Makefiles
A makefile can include other files. This is most commonly done to place common `make` definitions in a `make` header file or to include automatically generated dependency information.

When make encounters an include directive, it expands the wildcards and variable references, then tries to read the include file. If the file exists, we continue normally. If the file does not exist, however, `make` reports the problem and continues reading the rest of the makefile. When all reading is complete, `make` looks in the rules database for any rule to update the include files. If a match is found, `make` follows the normal process for updating a target. If any of the include files is updated by a rule, `make` then clears its internal database and rereads the entire makefile. If, after completing the process of reading, updating, and rereading, there are still `include` directives that have failed due to missing files, make terminates with an error status.

We can see this process in action with the following two-file example. We use the warning built-in function to print a simple message from `make`.  Here is the makefile:
```Makefile
# Simple makefile including a generated file.
include foo.mk
$(warning Finished include)
foo.mk: bar.mk
	m4 --define=FILENAME=$@ bar.mk > $@
```

If `make` cannot find the include file and it cannot create it using a rule, `make` exits with an error. If you want `make` to ignore include files it cannot load, add a leading dash to the `include` directive:
```Makefile
-include i-may-not-exist.mk
```

### How `make` Reads a Makefile
GNU `make` does its work in two distinct phases. During the first phase it reads all the makefiles, included makefiles, etc. and internalizes all the variables and their values, implicit and explicit rules, and constructs a dependency graph of all the targets and their prerequisites. During the second phase, `make` uses these internal structures to determine what targets will need to be rebuilt and to invoke the rules necessary to do so.

## Writing Rules
### Phony Targets
```
clean:
	rm *.o temp
```
In this example, the `clean` target will not work properly if a file named `clean` is ever created in this directory. Since it has no prerequisites, `clean` would always be considered up to date and its recipe would not be executed.

To avoid this problem you can explicitly declare the target to be phony by making it a prerequisite of the special target `.PHONY` as follows:
```Makefile
.PHONY: clean
clean:
	rm *.o temp
```

### Generating Prerequisites Automatically
In the makefile for a program, many of the rules you need to write often say only that some object file depends on some header file. For example, if `main.c` uses `defs.h` via an `#include`, you would write:
```Makefile
main.o: defs.h
```
You need this rule so that `make` knows that it must remake `main.o` whenever `defs.h` changes. You can see that for a large program you would have to write dozens of such rules in your makefile. And, you must always be very careful to update the makefile every time you add or remove an `#include`.

To avoid this hassle, most modern C compilers can write these rules for you, by looking at the `#include` lines in the source files. Usually this is done with the `'-M'` option to the compiler. For example, the command:
```
$ echo "#include <stdio.h>" > stdio.c
$ gcc -M stdio.c
stdio.o: stdio.c /usr/include/stdio.h /usr/include/_ansi.h \
  /usr/include/newlib.h /usr/include/sys/config.h \
  /usr/include/machine/ieeefp.h /usr/include/cygwin/config.h \
  /usr/lib/gcc-lib/i686-pc-cygwin/3.2/include/stddef.h \
  /usr/lib/gcc-lib/i686-pc-cygwin/3.2/include/stdarg.h \
  /usr/include/sys/reent.h /usr/include/sys/_types.h \
  /usr/include/sys/types.h /usr/include/machine/types.h \
  /usr/include/sys/features.h /usr/include/cygwin/types.h \
  /usr/include/sys/sysmacros.h /usr/include/stdint.h \
  /usr/include/sys/stdio.h
```
Thus you no longer have to write all those rules yourself. The compiler will do it for you.

With the GNU C compiler, you may wish to use the `'-MM'` flag instead of `'-M'`. This omits prerequisites on system header files.

There are two traditional methods for including automatically generated dependencies into makefiles.

If we generated each source file's dependencies into its own dependency file with, say, a `.d` suffix and added the `.d` file itself as a target to this dependency rule, then `make` could know that the `.d` needed to be updated (along with the object file) when the source file changed:
```
counter.o counter.d: src/counter.c include/counter.h include/lexer.h
```
Generating this rule can be accomplished with a pattern rule and a (fairly ugly) com- mand script
```Makefile
%d.: %.c
	$(CC) -M $(CPPFLAGS) $< > $@.$$$$;
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$
```
Now, for the cool feature. `make` will treat any file named in an `include` directive as a target to be updated. So, when we mention the `.d` files we want to include, `make` will automatically try to create these files as it reads the makefile. Here is our makefile with the addition of automatic dependency generation:
```Makefile
VPATH = src include
CPPFLAGS = -I include

SOURCES = count_words.c lexer.c counter.c

count_words: counter.o lexer.o -lfl
count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h

include $(subst .c,.d,$(SOURCES))

%d.: %.c
	$(CC) -M $(CPPFLAGS) $< > $@.$$$$;
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$
```
Here we use a make function, `subst`, to transform the list of source files into a list of dependency filenames. For now, just note that this use replaces the string `.c` with `.d` in each of the words in `$(SOURCES)`.

## Writing Recipes in Rules
### Errors in Recipes
After each shell invocation returns, `make` looks at its exit status. If the shell completed successfully (the exit status is zero), the next line in the recipe is executed in a new shell; after the last line is finished, the rule is finished.

If there is an error (the exit status is nonzero), make gives up on the current rule, and perhaps on all rules.

Sometimes the failure of a certain recipe line does not indicate a problem. For example, you may use the `mkdir` command to ensure that a directory exists. If the directory already exists, `mkdir` will report an error, but you probably want `make` to continue regardless.

To ignore errors in a recipe line, write a `'-'` at the beginning of the line's text (after the initial tab). The `'-'` is discarded before the line is passed to the shell for execution.

For example,
```Makefile
clean:
	-rm -f *.o
```
This causes `make` to continue even if `rm` is unable to remove a file.

## How to Use Variables
A *variable* is a name defined in a makefile to represent a string of text, called the variable's *value*.

### Basics of Variable References
either `'$(foo)'` or `'${foo}'` is a valid reference to the variable `foo`.

Variable references can be used in any context: targets, prerequisites, recipes, most directives, and new variable values. Here is an example of a common case, where a variable holds the names of all the object files in a program:
```Makefile
objects = program.o foo.o utils.o
program : $(objects)
	cc -o program $(objects)

$(objects) : defs.h
```

### The Two Flavors of Variables
There are two types of variables in make: simply expanded variables and recursively expanded variables. A *simply expanded* variable is defined using the `:=` assignment operator:
```
MAKE_DEPEND := $(CC) -M
```
It is called "simply expanded" because its righthand side is expanded immediately upon reading the line from the makefile.

The second type of variable is called a recursively expanded variable. A *recursively expanded* variable is defined using the `=` assignment operator:
```
MAKE_DEPEND = $(CC) -M
```
A better term for this variable might be *lazily expanded* variable, since the evaluation is deferred until it is actually used.
```
MAKE_DEPEND = $(CC) -M
...
# Some time later
CC = gcc
```
Here the value of `MAKE_DEPEND` within a command script is `gcc -M` even though `CC` was undefined when `MAKE_DEPEND` was assigned.

You can use them to introduce controlled leading whitespace into variable values. Leading whitespace characters are discarded from your input before substitution of variable references.
```
nullstring :=
space := $(nullstring) # end of the line
```
Here the value of the variable `space` is precisely one space. Since trailing space characters are *not* stripped from variable values, just a space at the end of the line would have the same effect.

### Advanced Features for Reference to Variables
#### Substitution References
A *substitution reference* substitutes the value of a variable with alterations that you specify. It has the form `'$(var:a=b)'` and its meaning is to take the value of the variable *var*, replace every *a* at the end of a word with *b* in that value, and substitute the resulting string.

For example:
```Makefile
foo := a.o b.o c.o
bar := $(foo:.o=.c)
```
sets `'bar'` to `'a.c b.c c.c'`.

Another type of substitution reference lets you use the full power of the `patsubst` function. It has the same form `'$(var:a=b)'` described above, except that now a must contain a single `'%'` character.
```
For example:

foo := a.o b.o c.o
bar := $(foo:%.o=%.c)
```
sets `'bar'` to `'a.c b.c c.c'`.

### Appending More Text to Variables
Often it is useful to add more text to the value of a variable already defined. You do this with a line containing `'+='`, like this:
```Makefile
objects += another.o
```
This takes the value of the variable `objects`, and adds the text `'another.o'` to it (preceded by a single space).

## Conditional Parts of Makefiles
### Syntax of Conditionals
The syntax of a simple conditional with no `else` is as follows:
```
conditional-directive
text-if-true
endif
```
There are four different directives that test different conditions. Here is a table of them: 
```
ifeq (arg1, arg2)
```
- Expand all variable references in *arg1* and *arg2* and compare them. If they are identical, the *text-if-true* is effective; otherwise, the *text-if-false*, if any, is effective.<br>
  Often you want to test if a variable has a non-empty value. When the value results from complex expansions of variables and functions, expansions you would consider empty may actually contain whitespace characters and thus are not seen as empty. However, you can use the `strip` function to avoid interpreting whitespace as a non-empty value. For example:
  ```
  ifeq ($(strip $(foo)),)
  text-if-empty
  endif
  ```
  will evaluate *text-if-empty* even if the expansion of `$(foo)` contains whitespace characters. 

## Functions for Transforming Text
### Functions for String Substitution and Analysis
```
$(strip string)
```
- Removes leading and trailing whitespace from *string* and replaces each internal sequence of one or more whitespace characters with a single space. Thus, `'$(strip a b c )'` results in `'a b c'`. 

## How to Run `make`

### Arguments to Specify the Goals
The *goals* are the targets that `make` should strive ultimately to update. Other targets are updated as well if they appear as prerequisites of goals, or prerequisites of prerequisites of goals, etc.

By default, the goal is the first target in the makefile. Therefore, makefiles are usually written so that the first target is for compiling the entire program or programs they describe. If the first rule in the makefile has several targets, only the first target in the rule becomes the default goal, not the whole list.

You can also specify a different goal or goals with command line arguments to `make`. Use the name of the goal as an argument. If you specify several goals, `make` processes each of them in turn, in the order you name them.

Any target in the makefile may be specified as a goal.

`Make` will set the special variable `MAKECMDGOALS` to the list of goals you specified on the command line. If no goals were given on the command line, this variable is empty.

### Instead of Executing Recipes
The makefile tells `make` how to tell whether a target is up to date, and how to update each target. But updating the targets is not always what you want. Certain options specify other activities for `make`.
```
-n
--dry-run
```
- "No-op". Causes `make` to print the recipes that are needed to make the targets up to date, but not actually execute them.

## Using Implicit Rules
### Chains of Implicit Rules
When `make` considers how to update a target, it searches the implicit rules for a tar- get pattern that matches the target in hand. For each target pattern that matches the target file, make will look for an existing matching prerequisite. That is, after matching the target pattern, `make` immediately looks for the prerequisite "source" file. If the prerequisite is found, the rule is used. But what if the source is not found after searching all possible rules? In this case, `make` will search the rules again, this time assuming that the matching source file should be considered as a new target for updating. By performing this search recursively, `make` can find a "chain" of rules that allows updating a target. 

One of the more impressive sequences that `make` can produce automatically from its database is shown here. First, we setup our experiment by creating an empty yacc source file and registering with RCS using `ci`:
```
$ touch foo.y
$ ci foo.y
foo.y,v  <--  foo.y
.
initial revision: 1.1
done
```
Now, we ask `make` how it would create the executable `foo`. The `-n` option tells `make` to report what actions it would perform without actually running them. Notice that we have no makefile and no "source" code, only an RCS file:
```
$ make -n foo
co  foo.y,v foo.y
foo.y,v  -->  foo.y
revision 1.1
done
bison -y  foo.y 
mv -f y.tab.c foo.c
gcc    -c -o foo.o foo.c
gcc   foo.o   -o foo
rm foo.c foo.o foo.y
```
Following the chain of implicit rules and prerequisites, `make` determined it could create the executable, `foo`, if it had the object file `foo.o`. It could create `foo.o` if it had the C source file `foo.c`. It could create `foo.c` if it had the yacc source file `foo.y`. Finally, it realized it could create `foo.y` by checking out the file from the RCS file `foo.y,v`, which it actually has. Once `make` has formulated this plan, it executes it by checking out `foo.y` with `co`, transforming it into `foo.c` with `bison`, compiling it into `foo.o` with `gcc`, and linking it to form `foo` again with `gcc`. All this from the implicit rules database.

The files generated by chaining rules are called *intermediate* files and are treated specially by make. First, since intermediate files do not occur in targets (otherwise they would not be intermediate), `make` will never simply update an intermediate file. Second, because `make` creates intermediate files itself as a side effect of updating a target, `make` will delete the intermediates before exiting. You can see this in the last line of the example.

### Defining and Redefining Pattern Rules
#### Introduction to Pattern Rules
A pattern rule contains the character `'%'` in the target; otherwise, it looks exactly like an ordinary rule. The target is a pattern for matching file names; the `'%'` matches any nonempty substring, while other characters match only themselves.

For example, `'%.c'` as a pattern matches any file name that ends in `'.c'`. The substring that the `'%'` matches is called the *stem*.

`'%'` in a prerequisite of a pattern rule stands for the same stem that was matched by the `'%'` in the target. In order for the pattern rule to apply, its target pattern must match the file name under consideration and all of its prerequisites (after pattern substitution) must name files that exist or can be made. These files become prerequisites of the target.

Thus, a rule of the form
```
%.o : %.c ; recipe…
```
specifies how to make a file `n.o`, with another file `n.c` as its prerequisite, provided that `n.c` exists or can be made.

#### Pattern Rule Examples
Here are some examples of pattern rules actually predefined in `make`. First, the rule that compiles `'.c'` files into `'.o'` files:
```
%.o : %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
```
defines a rule that can make any file `x.o` from `x.c`. The recipe uses the automatic variables `'$@'` and `'$<'` to substitute the names of the target file and the source file in each case where the rule applies.

#### Automatic Variables
Suppose you are writing a pattern rule to compile a `'.c'` file into a `'.o'` file: how do you write the `'cc'` command so that it operates on the right source file name? You cannot write the name in the recipe, because the name is different each time the implicit rule is applied.

What you do is use a special feature of `make`, the *automatic variables*. These variables have values computed afresh for each rule that is executed, based on the target and prerequisites of the rule. In this example, you would use `'$@'` for the object file name and `'$<'` for the source file name.
